## Работа 4. Детектирование границ документов на кадрах видео
автор: Клейменов В. Е.
дата: @time_stemp@
url: [https://github.com/hundredpercentdynamite/opencv-lab/tree/master/prj.labs/lab04](https://github.com/hundredpercentdynamite/opencv-lab/tree/master/prj.labs/lab04)

### Задание
0. текст, иллюстрации и подписи отчета придумываем самостоятельно
1. самостоятельно снимаем видео смартфоном
- объект съемки - купюры (рубли разного номинала), расправленные и лежащие на поверхности (проективно искаженный прямоугольник)
- количество роликов - от 5 шт.
- длительность - 5-7 сек
- условия съемки разные
2. извлекаем по 3 кадра из каждого ролика (делим кол-во кадров на 5 и берем каждый с индеком 2/5,3/5,4/5)
3. цветоредуцируем изображения
4. бинаризуем изображения
5. морфологически обрабатываем изображения
6. выделяем основную компоненту связности
7. руками изготавливаем маски (идеальная зона купюры)
8. оцениваем качество выделение зоны и анализируем ошибки

### Результаты

#### Исходные данные
Для работы была выбрана купюра номиналом 500 рублей, снятая на фотокамеру мобильного телефона.<br />
Съёмка проводилась при разном качестве освещения, в разных ракурсах на трёх фонах.
Всего отснято 7 видео роликов, из каждого ролика бралось по 3 кадра, обрабатывалось и сравнивалось с соответствующими эталонными масками, сделанными вручную.
##### Примеры кадров:
<img src="frame7_1.png" width="200" />
<img src="frame5_1.png" width="200" />
<img src="frame3_1.png" width="200" />
<img src="frame4_1.png" width="200" />
<img src="frame5_1.png" width="200" />
<img src="frame6_1.png" width="200" />
<img src="frame7_1.png" width="200" />

#### Описание алгоритма детектирования
1. Извлечение трёх кадров из каждого ролика.<br />
<img src="frame7_1.png" width="200" />
<img src="frame5_1.png" width="200" />
<img src="frame3_1.png" width="200" />
2. Преобразование цветов в оттенки серого с помощью `cvtColor`.<br />
<img src="frame7_1_gray.png" width="200" />
<img src="frame5_1_gray.png" width="200" />
<img src="frame3_1_gray.png" width="200" />
3. Бинаризация методом Отсу с параметрами: `thresh == 180`, `maxval == 255`.<br />
<img src="frame7_1_binary.png" width="200" />
<img src="frame5_1_binary.png" width="200" />
<img src="frame3_1_binary.png" width="200" />
4. Морфологическая эрозия изображения квадратным элементом размером 3x3 пикселя с якорем в центре.
5. Морфологическая дилотация квадратным элементом размером 9x9 пикселей с якорем в центре.<br />
<img src="frame7_1_mask.png" width="200" />
<img src="frame5_1_mask.png" width="200" />
<img src="frame3_1_mask.png" width="200" />
6. Выделение компонент связности и поиск наибольшей по площади компоненты.<br />
<img src="frame7_1_mask_pre_final.png" width="200" />
<img src="frame5_1_mask_pre_final.png" width="200" />
<img src="frame3_1_mask_pre_final.png" width="200" />
7. Морфологическое закрытие наибольшей компоненты квадратным элементом размером 15x15 пикселей с якорем в центре.<br />
<img src="frame7_1_mask_final.png" width="200" />
<img src="frame5_1_mask_final.png" width="200" />
<img src="frame3_1_mask_final.png" width="200" />
8. Сравнение полученной маски с эталонной.<br />
<img src="mask7_1_diff.png" width="200" />
<img src="mask5_1_diff.png" width="200" />
<img src="mask3_1_diff.png" width="200" />

#### Оценка качества
Получаемая маска оценивалась отношением общих с эталонной маской белых пикселей к количеству белых пикселей в объединении маски с эталоном.<br />
Иначе говоря, для оценки использовалась функция intersection over union.
Назовём этот показатель коэфициентом совпадения, он приведён вверху каждого изображения с результатами и обозначен буквой K.

Также, для визуальной оценки, эталонная маска накладывалась на изначальное серое изображение, а разница с полученной маской отмечена цветами:<br />
Красным - пиксели, отсутствующие на сгенерированной маске, но присутствующие в эталоне;<br />
Зелёным - пиксели, отсутствующие на эталоне, но присутствующие в сгенерированной маске.
Синим - пиксели, присутствующие и на маске, и на эталоне.

#### Выводы
Алгоритм отлично справляется с задачей на изображениях с контрастным фоном (светлая купюра, тёмный фон)
<img src="frame2_2.png" width="400" /><br />
Рис. 1. Изначальное изображение

<img src="frame2_2_mask.png" width="400" /><br />
Рис. 2. Полученная маска

<img src="mask2_2_diff.png" width="400" /><br />
Рис. 3. Сравнение маски с эталоном

На Рис. 3 вверху изображения обозначен полученный коэффициент совпадения масок, он равен 0.984.

Результаты на том же фоне, но с меньшим освещением. K = 0.968<br />
<img src="mask4_2_diff.png" width="400" /><br />
Рис. 4. Результат с меньшим освещением.

Хороший результат получается даже почти при полном отсутствии освещения, но на контрастном фоне.<br />
<img src="frame7_1.png" width="400" /><br />
Рис. 5. Изначальное изображение без освещения.

Заметен небольшой выброс на полученной маске. K = 0.974<br />
<img src="mask7_1_diff.png" width="400" /><br />
Рис. 6. Результат без освещения.

Алгоритм плохо справляется с задачей на светлых фонах:<br />
<img src="frame5_1.png" width="400" /><br />
Рис. 7. Купюра на светлом фоне.

K = 0.080
<img src="mask5_1_diff.png" width="400" /><br />
Рис. 8. Результат на светлом фоне.

Также, встречаются отклонения в работе при неоднородном фоне.
За набольшую компоненту связности была принята часть светлого фона. K = 0.000<br />
<img src="mask3_1_diff.png" width="400" /><br />
Рис. 9. Результат на неоднородном фоне.

Алгоритм хорошо показал себя в однозначных условиях отделимости купюры от фона даже при плохом освещении, но плохо справился с неоднородным и светлым фоном.

Средний коэффициент совпадения равен ~0.807.

### Текст программы
```cpp
@cpp_source@
```